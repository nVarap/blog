{
  
    
        "post0": {
            "title": "SASS Element Hacks",
            "content": "Classwork . Classwork . What are the 5 basic UI elements . Input | Navigation | Buttons | Text | Images | SASS SASS allows for greater variable storage of colors and various different styles. They are also far more compatible with various different ideas. . Advanced The @keyframes tag allows for us to store and recognize a set of keyframes. This is used in combination of the animation property. Fade class could be used to help run these animations as well. . Number Guessing Game It works by checking a number guessed in order to see if it is higher or lower, and then setting a text marker to be as such. Then, it will change color of the background depending on whether the answer is correct or incorrect . SASS makes this more appealing by adding color, so it isn’t just black-and-white . Hacks . . . Toggle Theme &lt;html&gt; &lt;head&gt; &lt;title&gt;Guess the Number&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Guess the Number&lt;/h1&gt; &lt;p&gt;Try to guess the number between 1 and 100.&lt;/p&gt; &lt;input type=&quot;text&quot; id=&quot;guess&quot; placeholder=&quot;Enter your guess&quot;&gt; &lt;button onclick=&quot;checkGuess()&quot;&gt;Submit&lt;/button&gt; &lt;p id=&quot;result&quot;&gt;&lt;/p&gt; &lt;script&gt; // Generate a random number between 1 and 100 const randomNumber = Math.floor(Math.random() * 100) + 1; let attempts = 0; function checkGuess() { // Get the user&#39;s guess const guess = parseInt(document.getElementById(&quot;guess&quot;).value); // Increase the number of attempts attempts++; // Check if the guess is correct if (guess === randomNumber) { document.getElementById(&quot;result&quot;).innerHTML = `Congratulations! You guessed the number in ${attempts} attempts.`; } else if (guess &lt; randomNumber) { document.getElementById(&quot;result&quot;).innerHTML = &quot;Too low. Guess again.&quot;; } else { document.getElementById(&quot;result&quot;).innerHTML = &quot;Too high. Guess again.&quot;; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; .",
            "url": "https://nvarap.github.io/blog/work/2023/04/27/cd.html",
            "relUrl": "/work/2023/04/27/cd.html",
            "date": " • Apr 27, 2023"
        }
        
    
  
    
        ,"post1": {
            "title": "The Scenario",
            "content": "Numpy and Pandas are powerful tools for data preprocessing in predictive analysis. Numpy can be used to perform mathematical operations on arrays and matrices, while Pandas can be used to manipulate and analyze structured data such as tables. Some common preprocessing tasks that can be performed with these tools include cleaning and formatting data, handling missing values, and transforming data into numerical formats suitable for machine learning algorithms. | There are many different machine learning algorithms that can be used for predictive analysis, including linear regression, logistic regression, decision trees, random forests, neural networks, and support vector machines. These algorithms differ in their underlying mathematical models, complexity, and performance characteristics. For example, linear regression models assume a linear relationship between the input and output variables, while neural networks can model highly nonlinear relationships. | Predictive analysis has many real-world applications across a variety of industries. Some examples include fraud detection in finance, predictive maintenance in manufacturing, demand forecasting in retail, and patient risk assessment in healthcare. | Feature engineering is the process of selecting, extracting, and transforming relevant features from raw data to improve model accuracy. This can involve techniques such as feature scaling, dimensionality reduction, and feature selection. By carefully selecting and engineering features, it is often possible to improve model accuracy and reduce overfitting. | Machine learning models can be deployed in real-time applications using a variety of technologies such as REST APIs, cloud platforms, and containerization. These technologies allow models to be deployed and scaled rapidly to meet the demands of real-world applications. | Numpy and Pandas are very powerful tools, but they do have some limitations. For example, they may not be the best choice for working with extremely large datasets, or for performing complex statistical analyses. In such cases, other tools such as Apache Spark or R may be more appropriate. | Predictive analysis can be used to improve decision-making and optimize business processes in a variety of ways. For example, it can help businesses identify high-risk customers, forecast demand for products, and optimize production schedules. By using data-driven insights to inform decisions, businesses can improve efficiency, reduce costs, and increase profitability. | import numpy as np from sklearn.linear_model import LinearRegression # Define the training data X_train = np.array([[1000], [1500], [2000], [2500], [3000]]) y_train = np.array([50000, 75000, 150000, 180000, 200000]) # Create and fit the linear regression model model = LinearRegression() model.fit(X_train, y_train) # Define the test data X_test = np.array([[1200], [1800], [2200], [2800], [3200]]) # Make predictions on the test data y_pred = model.predict(X_test) # Print the predicted prices print(y_pred) . [ 66200. 114800. 147200. 195800. 228200.] .",
            "url": "https://nvarap.github.io/blog/2023/04/27/TenserflowHacks.html",
            "relUrl": "/2023/04/27/TenserflowHacks.html",
            "date": " • Apr 27, 2023"
        }
        
    
  
    
        ,"post2": {
            "title": "SASS training",
            "content": "Classwork . What are the 5 basic UI elements . Input | Navigation | Buttons | Text | Images | SASS SASS allows for greater variable storage of colors and various different styles. They are also far more compatible with various different ideas. . Advanced The @keyframes tag allows for us to store and recognize a set of keyframes. This is used in combination of the animation property. Fade class could be used to help run these animations as well. . Number Guessing Game It works by checking a number guessed in order to see if it is higher or lower, and then setting a text marker to be as such. Then, it will change color of the background depending on whether the answer is correct or incorrect . SASS makes this more appealing by adding color, so it isn’t just black-and-white .",
            "url": "https://nvarap.github.io/blog/work/2023/04/26/b.html",
            "relUrl": "/work/2023/04/26/b.html",
            "date": " • Apr 26, 2023"
        }
        
    
  
    
        ,"post3": {
            "title": "Duck DNS Website",
            "content": "Hack 1 . Pros of Duck DNS: . Its free, and allows you to access domain services that allow users to assign a domain name specific to their website. | Access a device using a specific host name. Convenient as opposed to a port or other host name | Can use HTTPS or other form of hashing algorithm in order to protect data | Domain names can be custom in order to make stuff more accessible | . Cons of Duck DNS: . Not suitable for larger projects, or maybe unable to be scaled. | Depends on the connection of the device to the domain service, no direct connection in a way like ethernet or other form of connection | . . Hacks 2 . We use a DNS in order to host our flask projects on a local server in order to make sure that those who are on the internet can access our flask pages. DuckDNS takes our flask and hosts it on a local server stored in a server room elsewhere int eh world, sharing our information from our device and our AWS container to that server which attaches our hosted version to a different port, under a different name, thus allowing it to be hosted. To setup using duck DNS, we have to (1) Sign in with your DuckDNS account by selecting “Sign in with Github” (2) Then create a subdomain using (3) Change the IP address to the one you would like to link to(4) Click the IP address button and link to your subdomain. . Hack 3 (Not doing) . Hack 4 . I do not currently have any confusions regarding deployment. I found the process rather intuitive, and really the commands to be the primary issues. Mainly outdated and conflicting dependencies as a result of there being numerous people on the same instance. Also, there are some issues with the number of internet connections that need to occur in order to reach,a dn there are also issues with the idea of PUSD internet interfering with the process. Many of the issues we see really do happen because there aren’t necessarily fixes we see online. These are extreme corner cases that we come upon by sheer coincidence. . Hack 5 . . Hacks 6 . Hello, varalu running /Users/vn1/home/anaconda3/bin/python You will be asked 11 questions. Are you ready to take a test! Press Enter key to begin. Best of luck :) Question 1 : What does Domain Name Server represent? DNS is correct! Good Job! Question 2 : What does this Represent: Amazon Web Services, which is a cloud computing platform provided by Amazon. AWS is correct! Good Job! Question 3 : What is the first Step to setting up an AWS Server? 1: Connecting to a Ubuntu EC2 Instance, 2: Start updating the system, 3: Clone the repository which one wishes to deploy, 4: Run the command: main.py to start the project 1 is correct! Good Job! Question 4 : What is the third Step to setting up an AWS Server? 1: Connecting to a Ubuntu EC2 Instance, 2: Start updating the system, 3: Clone the repository which one wishes to deploy, 4: Run the command: main.py to start the project 3 is correct! Good Job! Question 5 : What is the fourth Step to setting up an AWS Server? 1: Connecting to a Ubuntu EC2 Instance, 2: Start updating the system, 3: Clone the repository which one wishes to deploy, 4: Run the command: main.py to start the project 4 is correct! Good Job! Question 6 : What is the second Step to setting up an AWS Server? 1: Connecting to a Ubuntu EC2 Instance, 2: Start updating the system, 3: Clone the repository which one wishes to deploy, 4: Run the command: main.py to start the project 2 is correct! Good Job! Question 7 : What files are you supposed to edit after finishing the first steps of setting up the server and cloning it within the AWS Server? 1: Edit the docker files and docker.yml, 2: Edit the main.py file to change the characteristcs. 1 is correct! Good Job! Question 8 : What is the first step to setting up a DuckDNS Server? 1: Sign in with your DuckDNS account using Github, 2: Configure current ip to the IP address that you want to access and click update ip button , 3: Create the subdomain, 4: Access site by typing in subdomain.duckdns.org 1 is correct! Good Job! Question 9 : What is the second step to setting up a DuckDNS Server? 1: Sign in with your DuckDNS account using Github, 2: Configure current ip to the IP address that you want to access and click update ip button , 3: Create the subdomain, 4: Access site by typing in subdomain.duckdns.org 3 is correct! Good Job! Question 10 : What is the third step to setting up a DuckDNS Server? 1: Sign in with your DuckDNS account using Github, 2: Configure current ip to the IP address that you want to access and click update ip button , 3: Create the subdomain, 4: Access site by typing in subdomain.duckdns.org 2 is correct! Good Job! Question 11 : What is the fourth step to setting up a DuckDNS Server? 1: Sign in with your DuckDNS account using Github, 2: Configure current ip to the IP address that you want to access and click update ip button , 3: Create the subdomain, 4: Access site by typing in subdomain.duckdns.org 4 is correct! Good Job! varalu you scored 11/11 Total Percentage: 100.00% . KASM Hacks . Virtual desktops and KASM (Kernel Adaptive Security Module) provide a secure environment to access data without compromising the host’s system. In an APCSP, we can use KASM to create a controlled environment with which students can contribute to code without suffering the consequences. Additionally, virtual desktops can be useful for facilitating collaboration among students and enabling remote instruction. VNCs could be used for cross-platform or long-distance collaboration, as we see with splashtop in the CTE department. . KASM Team Work . . AWS Database Quizzes . Quiz 1 . C | D | C | Quiz 2 . C | A | C | Certbot hacks . Certbot Hacks 1: . I could not install the Certbot package, and thus was unable to get a screenshot of Certbot working . Certbot Hacks 2: . OpenSSL is an open-source implementation of SSL/TLS protocols that is widely used for secure communication on the Internet. It offers a range of cryptographic features, including encryption, decryption, digital signatures, and hash functions. LibreSSL, on the other hand, is a fork of OpenSSL that was created in 2014 after the discovery of the Heartbleed vulnerability. In terms of security features, both OpenSSL and LibreSSL offer similar capabilities, such as support for strong cryptographic algorithms, certificate validation, and secure key management. In March 2021, OpenSSL released a security advisory that addressed three vulnerabilities, including a high-severity flaw that could allow an attacker to perform a denial-of-service attack or execute arbitrary code on a vulnerable system. .",
            "url": "https://nvarap.github.io/blog/work/2023/04/26/a.html",
            "relUrl": "/work/2023/04/26/a.html",
            "date": " • Apr 26, 2023"
        }
        
    
  
    
        ,"post4": {
            "title": "P4-Y 4/25 Guide to SASS",
            "content": "WGET this file and complete fully and thoroughly in order to be receive credit . Wget Link . Team Lesson Plan: . SASS Part 1- Nathan, Aniket, Kalani . Basic UI Properties and what they mean | Color properties | Themes | SASS Definition/What it is useful for | SASS code segments w/ comparison to css | Demonstration of SASS | . SASS Part 2- Max W, Evan . More UI Properties | UX | Layouts | Animation/animation code for UI | . Building JavaScript Game or Application- Ryan, Jaden . Before vs After Minesweeper Game - how to customize | Building a java script game and what it requires | . Hacks Page - Kalani, Max T . Students must create their own hack (simple app,game, etc using key components from the lesson) | Make sure the students can wget the file so they can work on it for their hacks | . Classwork: . What are 5 Basic UI Elements?: . div | p | header | body | In your own words, explain what SASS does: . SASS is an extension of CSS, allowing for more intuitive and scalable UI design through variables. | . What are some benefits to SASS?: . More intuitive | More stuff that can be used, such as variables that can be used. | . Describe/Explain one of the more &quot;advanced&quot; SASS properties below in detail: . @media can be used to determine the medium, such as the device, that is used with the application, allowing for change | . Link to Number Guesser Game . How does the number guesser game work? . It takes input via an input tag, checks it to the number that has been guessed, and then determines whether they have been chosen. | . Explain how SASS can be used to make the number guesser game look more visually appealing? . SASS can be used to alter the background and the various text colors in the image, as opposed to just simply having a blank white screen at any point in time. | . Hacks - Insert any screenshots, code segments, etc. that you need to in order to demonstrate an understanding of the hacks . Hacks Part 1 . Add your own element to your own repository to make it unique (0.9) | Hacks Part 2 . Add the style change button to your own github page (0.9) Change the button to your own styles | See if you can let make it change to multiple different styles (we understand that it is hard to create multiple distinct styles so you are only required to make it clear you have at least three different styles at can be changed) | . | Extra: Try and incorporate something you learned in the lesson into your CPT Project (0.1) | Hacks Part 3 . Add SASS to Number Guesser Game provided (0.9) or create your own Javascript game/application and add SASS to it (0.9+) | We will collectively decide on the &quot;best&quot; game/app and award potential seed. | Copy and paste the following code segment into a markdown file which will be used for the hacks: . Guess the Number . Guess the Number . Try to guess the number between 1 and 100. . Submit . .",
            "url": "https://nvarap.github.io/blog/student/2023/04/25/P4Y-SASSGuide.html",
            "relUrl": "/student/2023/04/25/P4Y-SASSGuide.html",
            "date": " • Apr 25, 2023"
        }
        
    
  
    
        ,"post5": {
            "title": "Numpy, Pandas, and Tenser Flow",
            "content": "What is Numpy? . It stands for Numerical python. It is a python package which is used to perform a wide variety of mathematical operations on arrays and works faster than a regular python list. . What can we do with Numpy? . One of the easiest things to do with Numpy is to change the shape of an array . import numpy as np a = np.array([1, 2, 3, 4, 5, 6]) print(a) b = np.reshape( a, # the array being reshaped (2,3) # dimensions of the new array ) print(b) c = np.reshape( a, (6,1) ) print(c) . [1 2 3 4 5 6] [[1 2 3] [4 5 6]] [[1] [2] [3] [4] [5] [6]] . Create two dimensional array. . a_list = [[1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]] d = np.array([a_list]) d . array([[[1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]]]) . Accessing Elements: Can find a specific index, similar to regular python lists . z1 = np.random.randint (10, size=6) z1[0] # Find an index . 8 . z1[0:2] # Create an array of the specified range . array([2, 8]) . z1[-1] # Get last element of the list . 6 . Using Numpy With Images . from skimage import io photo = io.imread(&#39;san_diego.jpg&#39;) type(photo) . numpy.ndarray . import matplotlib.pyplot as plt plt.imshow(photo) photo.shape . (549, 976, 3) . Output a mirror image . plt.imshow(photo[::-1]) . &lt;matplotlib.image.AxesImage at 0x7f8c20a3d9d0&gt; . Find specific part of the image by putting axes into an array . plt.imshow(photo[150:400, 675:775]) . &lt;matplotlib.image.AxesImage at 0x7f8c1885d520&gt; . Reduce the size of an image . plt.imshow(photo[::2, ::2]) . &lt;matplotlib.image.AxesImage at 0x7f8c18830f70&gt; . Can use Numpy math functions to find values related to an image . photo photo_sin = np.sin(photo) photo_sin . array([[[-0.355 , 0.8857 , 0.9946 ], [-0.355 , 0.8857 , 0.9946 ], [-0.355 , 0.8857 , 0.9946 ], ..., [ 0.3467 , -0.9985 , -0.5063 ], [ 0.9766 , -0.491 , 0.452 ], [ 0.9766 , -0.491 , 0.452 ]], [[-0.355 , 0.8857 , 0.9946 ], [-0.355 , 0.8857 , 0.9946 ], [-0.355 , 0.8857 , 0.9946 ], ..., [ 0.9766 , -0.491 , 0.452 ], [ 0.9766 , -0.491 , 0.452 ], [ 0.9766 , -0.491 , 0.452 ]], [[-0.355 , 0.8857 , 0.9946 ], [-0.355 , 0.8857 , 0.9946 ], [-0.355 , 0.8857 , 0.9946 ], ..., [ 0.9766 , -0.491 , 0.452 ], [ 0.7085 , 0.4678 , 0.9946 ], [ 0.7085 , 0.4678 , 0.9946 ]], ..., [[-0.404 , -0.677 , 0.869 ], [-0.1323 , -0.02655, 0.721 ], [ 0.9907 , -0.5586 , -0.46 ], ..., [-0.906 , -0.9663 , -0.1935 ], [-0.846 , -0.305 , -0.8115 ], [-0.906 , -0.305 , -0.7905 ]], [[ 0.5513 , -0.9854 , 0.8857 ], [ 0.5293 , -0.3877 , -0.9424 ], [-0.988 , 0.774 , 0.6963 ], ..., [-0.846 , -0.7393 , -0.1935 ], [-0.751 , -0.5215 , 0.9727 ], [-0.2878 , -0.5586 , -0.1935 ]], [[-0.751 , -0.305 , 0.5806 ], [-1. , 0.987 , 0.785 ], [-0.757 , 0.0177 , -0.09717], ..., [-0.846 , 0.92 , -0.93 ], [ 0.6504 , -0.9995 , -0.616 ], [-1. , 0.6704 , -0.46 ]]], dtype=float16) . Numpy Hacks . For your hacks, use matplotlib and numpy to slice this image to display Waldo. Also find and display one other numpy function and blog about what it is used for. . photo_a = io.imread(&#39;waldo.jpg&#39;) type(photo_a) plt.imshow(photo_a) . &lt;matplotlib.image.AxesImage at 0x7f8c18782f70&gt; . What is Pandas? . Pandas is an open source Python package which is used for data analysis and machine learning. Pandas is built using numpy which supports it using multidimensional arrays such as what is shown below: . Data can then be manipulated using pandas to do all sorts of different things such as data cleaning, statistical analysis, and data visualization. Below is an example of data visualization in a table using pandas. . import pandas as pd pd.__version__ . &#39;1.4.2&#39; . classes = pd.Series([&quot;Mathematics&quot;,&quot;Chemistry&quot;,&quot;Physics&quot;,&quot;History&quot;,&quot;Geography&quot;,&quot;German&quot;]) grades = pd.Series([90,54,77,22,25]) pd.DataFrame({&quot;Classes&quot;: classes, &quot;Grades&quot;: grades}) . Classes Grades . 0 Mathematics | 90.0 | . 1 Chemistry | 54.0 | . 2 Physics | 77.0 | . 3 History | 22.0 | . 4 Geography | 25.0 | . 5 German | NaN | . What is TenserFlow? . Tensor Flow is a machine learning platform which has tools to validate and transform large datasets and also provides standard datasets for machine learning training. . An example of this is the fashion MNIST (Modified National Institute of Standards and Technology) database: . In this dataset there are many pictures which are each28x28 Numpy arrays. . Setting up . This will train a neural network model to identify pictures of clothing. We will use tf.keras, a high-level API to build and train models in TensorFlow. . import tensorflow as tf # Helper libraries import numpy as np import matplotlib.pyplot as plt print(tf.__version__) . 2.12.0 . We will use the Fashion MNIST dataset which contains 70,000 grayscale images in 10 categories. Here we will load the database. . fashion_mnist = tf.keras.datasets.fashion_mnist (train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data() . Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/train-labels-idx1-ubyte.gz 29515/29515 [==============================] - 0s 0us/step Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/train-images-idx3-ubyte.gz 26421880/26421880 [==============================] - 2s 0us/step Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/t10k-labels-idx1-ubyte.gz 5148/5148 [==============================] - 0s 0us/step Downloading data from https://storage.googleapis.com/tensorflow/tf-keras-datasets/t10k-images-idx3-ubyte.gz 4422102/4422102 [==============================] - 0s 0us/step . This dataset loads 4 NumPy arrays: train_images and train_labels arrays are the training set, used for the models to learn test_images and test_labels arrays test the accuracy . Each imaged is mapped to a label. The class names are not included with the dataset, store them here to use later when plotting images: . class_names = [&#39;T-shirt/top&#39;, &#39;Trouser&#39;, &#39;Pullover&#39;, &#39;Dress&#39;, &#39;Coat&#39;, &#39;Sandal&#39;, &#39;Shirt&#39;, &#39;Sneaker&#39;, &#39;Bag&#39;, &#39;Ankle boot&#39;] . Let&#39;s explore the format of the dataset before training the model. The following shows there are 60,000 images in the training set, with each image represented as 28 x 28 pixels: . train_images.shape . (60000, 28, 28) . Likewise, there are 60,000 labels in the training set: . len(train_labels) . 60000 . Each label is an integer between 0 and 9: . train_labels . array([9, 0, 0, ..., 3, 0, 5], dtype=uint8) . There are 10,000 images in the test set. Again, each image is represented as 28 x 28 pixels: . test_images.shape . (10000, 28, 28) . And the test set contains 10,000 images labels: . len(test_labels) . 10000 . Preprocessing data . The data must be preprocessed before training the network. If you inspect the first image in the training set, you will see that the pixel values fall in the range of 0 to 255: . plt.figure() plt.imshow(train_images[0]) plt.colorbar() plt.grid(False) plt.show() . Scale these values to a range of 0 to 1 before feeding them to the neural network model. To do so, divide the values by 255. It&#39;s important that the training set and the testing set be preprocessed in the same way: . train_images = train_images / 255.0 test_images = test_images / 255.0 . To verify that the data is in the correct format and that you&#39;re ready to build and train the network, let&#39;s display the first 25 images from the training set and display the class name below each image. . plt.figure(figsize=(10,10)) for i in range(25): plt.subplot(5,5,i+1) plt.xticks([]) plt.yticks([]) plt.grid(False) plt.imshow(train_images[i], cmap=plt.cm.binary) plt.xlabel(class_names[train_labels[i]]) plt.show() . Building the neural network requires configuring the layers of the model, then compiling the model. . The basic building block of a neural network is the layer. Layers extract representations from the data fed into them. Hopefully, these representations are meaningful for the problem at hand. . Most of deep learning consists of chaining together simple layers. Most layers, such as tf.keras.layers.Dense, have parameters that are learned during training. . model = tf.keras.Sequential([ tf.keras.layers.Flatten(input_shape=(28, 28)), tf.keras.layers.Dense(128, activation=&#39;relu&#39;), tf.keras.layers.Dense(10) ]) . The first layer in this network, tf.keras.layers.Flatten, transforms the format of the images from a two-dimensional array (of 28 by 28 pixels) to a one-dimensional array (of 28 * 28 = 784 pixels). Think of this layer as unstacking rows of pixels in the image and lining them up. This layer has no parameters to learn; it only reformats the data. . After the pixels are flattened, the network consists of a sequence of two tf.keras.layers.Dense layers. These are densely connected, or fully connected, neural layers. The first Dense layer has 128 nodes (or neurons). The second layer returns a logits array with length of 10. Each node contains a score that indicates the current image belongs to one of the 10 classes. . Before the model is ready for training, it needs a few more settings. These are added during the model&#39;s compile step: . Loss function —This measures how accurate the model is during training. You want to minimize this function to &quot;steer&quot; the model in the right direction. | Optimizer —This is how the model is updated based on the data it sees and its loss function. | Metrics —Used to monitor the training and testing steps. The following example uses accuracy, the fraction of the images that are correctly classified. | . model.compile(optimizer=&#39;adam&#39;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=[&#39;accuracy&#39;]) . Training . Training the neural network model requires the following steps: . Feed the training data to the model. (train_images and train_labels arrays.) | The model learns to associate images and labels. | You ask the model to make predictions about a test set (test_images array) | Verify that the predictions match the labels from the test_labels array. | . To start training, call the model.fit method . model.fit(train_images, train_labels, epochs=10) . Epoch 1/10 . 2023-04-04 11:53:51.070373: W tensorflow/tsl/framework/cpu_allocator_impl.cc:83] Allocation of 188160000 exceeds 10% of free system memory. . 1875/1875 [==============================] - 11s 6ms/step - loss: 0.4959 - accuracy: 0.8268 Epoch 2/10 1875/1875 [==============================] - 10s 5ms/step - loss: 0.3762 - accuracy: 0.8651 Epoch 3/10 1875/1875 [==============================] - 10s 6ms/step - loss: 0.3361 - accuracy: 0.8778 Epoch 4/10 1875/1875 [==============================] - 10s 6ms/step - loss: 0.3130 - accuracy: 0.8860 Epoch 5/10 1875/1875 [==============================] - 10s 5ms/step - loss: 0.2946 - accuracy: 0.8903 Epoch 6/10 1875/1875 [==============================] - 10s 5ms/step - loss: 0.2816 - accuracy: 0.8958 Epoch 7/10 1875/1875 [==============================] - 10s 5ms/step - loss: 0.2679 - accuracy: 0.9011 Epoch 8/10 1875/1875 [==============================] - 10s 5ms/step - loss: 0.2578 - accuracy: 0.9027 Epoch 9/10 1875/1875 [==============================] - 10s 5ms/step - loss: 0.2494 - accuracy: 0.9062 Epoch 10/10 1875/1875 [==============================] - 11s 6ms/step - loss: 0.2393 - accuracy: 0.9107 . &lt;keras.callbacks.History at 0x7f41ac3327f0&gt; . As the model trains, the loss and accuracy metrics are displayed. This model reaches an accuracy of about 0.91 (or 91%) on the training data. . Next, compare how the model performs on the test dataset: . test_loss, test_acc = model.evaluate(test_images, test_labels, verbose=2) print(&#39; nTest accuracy:&#39;, test_acc) . 313/313 - 1s - loss: 0.3225 - accuracy: 0.8908 - 1s/epoch - 3ms/step Test accuracy: 0.8907999992370605 . It turns out that the accuracy on the test dataset is a little less than the accuracy on the training dataset. This gap between training accuracy and test accuracy represents overfitting. Overfitting is when a machine learning model performs worse on new, previouly unseen inputs than on the training data. . Predicting Images . With the model trained, you can use it to make predictions about some images. Attach a softmax layer to convert the model&#39;s linear outputs (logits) to probabilities, which should be easier to interpret. . probability_model = tf.keras.Sequential([model, tf.keras.layers.Softmax()]) . predictions = probability_model.predict(test_images) . 313/313 [==============================] - 1s 3ms/step . Here, the model has predicted the label for each image in the testing set. Let&#39;s take a look at the first prediction: . predictions[0] . array([1.7737974e-10, 9.8017128e-10, 2.4250555e-08, 2.7087502e-10, 3.3816602e-11, 7.0955430e-04, 1.5008560e-09, 2.1424549e-02, 2.1235054e-09, 9.7786587e-01], dtype=float32) . A prediction is an array of 10 numbers. They represent the model&#39;s &quot;confidence&quot; that the image corresponds to each of the 10 different articles of clothing. You can see which label has the highest confidence value: . np.argmax(predictions[0]) . 9 . So, the model is most confident that this image is an ankle boot, or class_names[9]. Examining the test label shows that this classification is correct: . test_labels[0] . 9 . Graph this to look at the full set of 10 class predictions. . def plot_image(i, predictions_array, true_label, img): true_label, img = true_label[i], img[i] plt.grid(False) plt.xticks([]) plt.yticks([]) plt.imshow(img, cmap=plt.cm.binary) predicted_label = np.argmax(predictions_array) if predicted_label == true_label: color = &#39;blue&#39; else: color = &#39;red&#39; plt.xlabel(&quot;{} {:2.0f}% ({})&quot;.format(class_names[predicted_label], 100*np.max(predictions_array), class_names[true_label]), color=color) def plot_value_array(i, predictions_array, true_label): true_label = true_label[i] plt.grid(False) plt.xticks(range(10)) plt.yticks([]) thisplot = plt.bar(range(10), predictions_array, color=&quot;#777777&quot;) plt.ylim([0, 1]) predicted_label = np.argmax(predictions_array) thisplot[predicted_label].set_color(&#39;red&#39;) thisplot[true_label].set_color(&#39;blue&#39;) . With the model trained, you can use it to make predictions about some images. . Let&#39;s look at the 0th image, predictions, and prediction array. Correct prediction labels are blue and incorrect prediction labels are red. The number gives the percentage (out of 100) for the predicted label. . i = 0 plt.figure(figsize=(6,3)) plt.subplot(1,2,1) plot_image(i, predictions[i], test_labels, test_images) plt.subplot(1,2,2) plot_value_array(i, predictions[i], test_labels) plt.show() . i = 12 plt.figure(figsize=(6,3)) plt.subplot(1,2,1) plot_image(i, predictions[i], test_labels, test_images) plt.subplot(1,2,2) plot_value_array(i, predictions[i], test_labels) plt.show() . Let&#39;s plot several images with their predictions. Note that the model can be wrong even when very confident. . # Color correct predictions in blue and incorrect predictions in red. num_rows = 5 num_cols = 3 num_images = num_rows*num_cols plt.figure(figsize=(2*2*num_cols, 2*num_rows)) for i in range(num_images): plt.subplot(num_rows, 2*num_cols, 2*i+1) plot_image(i, predictions[i], test_labels, test_images) plt.subplot(num_rows, 2*num_cols, 2*i+2) plot_value_array(i, predictions[i], test_labels) plt.tight_layout() plt.show() . Finally, use the trained model to make a prediction about a single image. . img = test_images[1] print(img.shape) . (28, 28) . tf.keras models are optimized to make predictions on a batch, or collection, of examples at once. Accordingly, even though you&#39;re using a single image, you need to add it to a list: . img = (np.expand_dims(img,0)) print(img.shape) . (1, 28, 28) . Now predict the correct label for this image: . predictions_single = probability_model.predict(img) print(predictions_single) . 1/1 [==============================] - 0s 52ms/step [[1.0949210e-05 4.1276347e-11 9.9810290e-01 1.2848138e-10 1.0825287e-03 1.3133799e-13 8.0366491e-04 1.1366387e-15 3.2978012e-10 1.3686339e-15]] . plot_value_array(1, predictions_single[0], test_labels) _ = plt.xticks(range(10), class_names, rotation=45) plt.show() . tf.keras.Model.predict returns a list of lists, one list for each image in the batch of data. Grab the predictions for our (only) image in the batch: . np.argmax(predictions_single[0]) . 2 . And the model predicts a label as expected. .",
            "url": "https://nvarap.github.io/blog/jupyter/week-28/2023/04/03/TenserFlow.html",
            "relUrl": "/jupyter/week-28/2023/04/03/TenserFlow.html",
            "date": " • Apr 3, 2023"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This blog pertains to Varaprasad N, APCSP 1 Student. . Hobbies . I enjoy playing multiple games, mainly board games or TCGs 2 such as . The Pokémon TCG | The Yu-Gi-Oh TCG | Magic: The Gathering | . I also love to play Dungeons and Dragons, a TTRPG 3. I am also the President of the Tabletop Games club at my school . Clubs . I am a part of the Model United Nations Club, Dungeons and Dragons club, and Robotics . . Advanced Placement: Computer Science &#8617; . | Trading Card Games &#8617; . | Table Top RPG &#8617; . |",
          "url": "https://nvarap.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  
  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://nvarap.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}